# Улучшения для JEEX Plan с PostgreSQL 18

## Введение

PostgreSQL 18 принесает множество улучшений, которые могут значительно улучшить производительность, безопасность и функциональность нашего проекта JEEX Plan. Ниже приведены рекомендации по внедрению новых возможностей PostgreSQL 18 в наше веб-приложение на Python с использованием SQLAlchemy.

## 1. Асинхронный I/O для повышения производительности

### 1.1. Описание

PostgreSQL 18 улучшает производительность за счет асинхронной обработки операций ввода-вывода, особенно на Linux 5.1+ с поддержкой io_uring. Это включает в себя более быстрые последовательные сканирования, bitmap heap сканирования и операции VACUUM.

### 1.2. Применение к нашему проекту

- Наше приложение использует асинхронные соединения с базой данных через SQLAlchemy и asyncpg
- Уже настроена оптимизация пула соединений, но мы можем дополнительно оптимизировать настройки для использования асинхронного I/O
- Это особенно полезно при работе с большими объемами данных в моделях `document_versions` и `documents`

### 1.3. Рекомендация

Обновить настройки подключения к базе данных в `app/core/database.py` для оптимизации под асинхронный I/O:

```python
engine = create_async_engine(
    ASYNC_DATABASE_URL,
    echo=settings.DEBUG,
    pool_size=20,
    max_overflow=30,
    pool_pre_ping=True,
    pool_recycle=300,
    # Добавить параметры, связанные с асинхронным I/O
    server_settings={
        "effective_io_concurrency": "200",  # Для поддержки асинхронного I/O
        "random_page_cost": "1.1"  # Оптимизация для SSD
    }
)
```

## 2. Использование UUIDv7 для улучшения индексации

### 2.1. Описание

UUIDv7 включает временные метки в первые 48 бит, что значительно улучшает локальность данных и производительность индексов по сравнению с случайными UUID.

### 2.2. Применение к нашему проекту

- В наших моделях (`User`, `Tenant`, `Project` и других) мы используем UUID в качестве первичного ключа
- Текущая реализация использует `uuid.uuid4()`, что создает случайные UUID
- Замена на UUIDv7 может улучшить производительность индексов и уменьшить фрагментацию

### 2.3. Рекомендация

Обновить базовую модель в `app/models/base.py`:

```python
from sqlalchemy import func
from sqlalchemy.dialects.postgresql import UUID as PostgresUUID

class BaseModel(Base, TimestampMixin, TenantMixin, SoftDeleteMixin):
    """Base model with common fields for all entities."""

    __abstract__ = True

    id: Mapped[uuid.UUID] = mapped_column(
        PostgresUUID(as_uuid=True), 
        primary_key=True, 
        # Использовать UUIDv7 вместо случайного UUID
        server_default=func.uuidv7(), 
        index=True
    )
```

## 3. Skip Scans для оптимизации запросов

### 3.1. Описание

Skip scans позволяют использовать многостолбцовые индексы даже когда не все столбцы присутствуют в WHERE, особенно эффективно при низкой кардинальности одного из столбцов.

### 3.2. Применение к нашему проекту

- В нашей системе мульти-тенантности часто встречаются запросы с фильтрацией по `tenant_id` и другим полям
- Наши индексы, такие как в миграции `0aad7c4f25d0_update_indexes.py`, могут быть оптимизированы для использования skip scans
- Это может улучшить производительность запросов к таблицам `document_versions`, `projects`, `users`

### 3.3. Рекомендация

Добавить многостолбцовые индексы в наши модели, где это целесообразно:

```python
# В модели User
__table_args__ = (
    UniqueConstraint("tenant_id", "email", name="uq_user_tenant_email"),
    UniqueConstraint("tenant_id", "username", name="uq_user_tenant_username"),
    # Добавить многостолбцовый индекс для skip scans
    Index("idx_user_tenant_active", "tenant_id", "is_active"),
)

# В модели DocumentVersion (из миграции)
# Уже есть многостолбцовые индексы, которые могут использовать skip scans
```

## 4. Виртуальные вычисляемые столбцы

### 4.1. Описание

Виртуальные вычисляемые столбцы вычисляются на лету без сохранения на диск, упрощают работу с JSONB данными и улучшают производительность.

### 4.2. Применение к нашему проекту

- В проекте могут использоваться JSONB поля для хранения конфигураций, настроек или метаданных
- Виртуальные столбцы могут упростить доступ к часто используемым данным из JSONB полей

### 4.3. Рекомендация

Если у нас есть JSONB поля (например, конфигурации агентов), можно добавить виртуальные вычисляемые столбцы:

```python
# Пример для модели Project, если есть JSONB поле с настройками
from sqlalchemy import JSON

class Project(BaseModel):
    # ... существующие поля ...
    config: Mapped[dict | None] = mapped_column(JSON, nullable=True)
    # Виртуальный вычисляемый столбец для часто используемых значений
    agent_mode: Mapped[str] = mapped_column(
        String, 
        Computed("config->>'agent_mode'", persisted=False),  # persisted=False для виртуального столбца
        nullable=True
    )
```

## 5. Поддержка OAuth 2.0 в PostgreSQL

### 5.1. Описание

PostgreSQL 18 добавляет поддержку OAuth 2.0 для аутентификации, позволяя использовать bearer токены вместо паролей.

### 5.2. Применение к нашему проекту

- В нашей модели User уже есть поля для OAuth (`oauth_provider`, `oauth_id`)
- PostgreSQL может управлять аутентификацией через OAuth, что улучшит безопасность

### 5.3. Рекомендация

- Рассмотреть настройку pg_hba.conf для использования метода аутентификации peer с OAuth
- Это может сократить код приложения, связанный с управлением сессиями и аутентификацией
- Потребует более глубокого изучения для интеграции с уже существующей системой аутентификации FastAPI

## Заключение

Внедрение этих улучшений PostgreSQL 18 может значительно повысить производительность, безопасность и функциональность нашего приложения JEEX Plan. Особенно важными являются переход на UUIDv7 для улучшения индексации и использование skip scans для оптимизации частых запросов в мульти-тенантной архитектуре.

Рекомендуется внедрять эти изменения постепенно, начиная с UUIDv7 и оптимизации индексов, так как они принесут наибольшую пользу для текущей архитектуры.
