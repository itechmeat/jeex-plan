# Архитектура JEEX Plan

> **Техническая спецификация:** Детальные технические требования, API, схемы БД и конфигурации описаны в [specs.md](specs.md)

## 1) Назначение и границы

- Продукт превращает «сырую» идею в профессиональный пакет Markdown-документов: Description → Engineering Specs → Architecture → Implementation Plan.
- Формат работы — диалоговый мастер из 4 шагов с понятным прогрессом и возможностью быстрой итерации (правки в диалоге автоматически попадают в документы).
- Ценностные требования: изоляция знаний между проектами/тенантами, воспроизводимость (версионирование документов), объяснимость результатов (структурные шаблоны, валидации), скорость отклика (стриминг), расширяемость (подключаемые партнёрские рекомендации).

## 2) Архитектурные принципы

- **Single-Responsibility компонентов**: UI, API, оркестрация агентов, память/поиск, долговременное хранилище, кэш/квоты, экспорт, наблюдаемость.
- **Чёткий контекст проекта**: любой агент и любой поиск работают только в пределах `(tenant_id, project_id)`.
- **Server-side enforcement**: клиент никогда не задаёт фильтры напрямую для памяти/поиска; фильтр формируется и подписывается на бэкенде.
- **Потоковая отдача**: все длинные операции отдают прогресс и промежуточные результаты через SSE.
- **Версионирование как договор**: каждая значимая генерация/правка — новая версия артефакта, чтобы пользователь в любой момент мог «свернуть» изменения.
- **Наблюдаемость по умолчанию**: OpenTelemetry для distributed tracing с корреляционными ID и автоматической инструментацией FastAPI.
- **Resilience patterns**: Tenacity для retry logic и circuit breakers при взаимодействии с внешними LLM API для предотвращения каскадных сбоев.

## 3) Логическая схема (высокоуровнево)

```mermaid
graph TB
    subgraph "Frontend Layer"
        UI[Web Frontend<br/>React/TS<br/>4-Step Wizard]
    end

    subgraph "API Layer"
        API[API Gateway<br/>FastAPI + Security Middleware<br/>Auth, Rate Limiting & SSE]
        RP[Reverse Proxy<br/>TLS & Compression]
    end

    subgraph "Processing Layer"
        ORCH[Agent Orchestrator<br/>Crew + Resilience Patterns<br/>I/O Contracts & Circuit Breakers]
        EMB[Embedding Service<br/>Text Normalization<br/>Vector Computation]
        QA[Quality Assurance<br/>Readability & Grammar<br/>Content Validation]
    end

    subgraph "Storage Layer"
        QDRANT[Vector Store<br/>Qdrant<br/>Multi-tenant Memory]
        PRIMARY[Primary Store<br/>Documents & Versions]
        REDIS[Cache/Queue<br/>Redis<br/>Limits & Progress]
    end

    subgraph "Observability"
        OBS[Observability<br/>OpenTelemetry Stack<br/>Auto-instrumentation & Tracing]
    end

    subgraph "Agents"
        BA[Business Analyst]
        ES[Engineering Standards]
        SA[Solution Architect]
        PP[Project Planner]
    end

    UI --> RP
    RP --> API
    API --> ORCH
    ORCH --> BA
    ORCH --> ES
    ORCH --> SA
    ORCH --> PP
    ORCH --> EMB
    ORCH --> QA
    EMB --> QDRANT
    QA --> PRIMARY
    ORCH --> PRIMARY
    API --> REDIS

    BA -.-> QDRANT
    ES -.-> QDRANT
    SA -.-> QDRANT
    PP -.-> QDRANT

    API --> OBS
    ORCH --> OBS
    EMB --> OBS
    QDRANT --> OBS
```

**Состав:**

- **Web Frontend** (React/TS): мастер из 4 шагов, предпросмотр и дифф-подсветка, панель прогресса, скачивание архива.
- **API-шлюз / Backend** (FastAPI): аутентификация (OAuth2), SSE-стриминг, лимиты, сбор/агрегация телеметрии, экспорт, партнёрские рекомендации.
- **Оркестратор агентов** (Crew-подход + строгие контрактные модели I/O): роли Business Analyst, Engineering Standards, Solution Architect, Project Planner.
- **Сервис эмбеддингов** (абстракция над выбранной моделью): нормализация текста, чанкинг, дедупликация, вычисление векторов.
- **Vector Store** (Qdrant): память/контекст проекта, поиск знаний с фильтрами по тенанту/проекту; мультитенантный подход (см. раздел 6).
- **Primary Store** (документы/версии/настройки): долговременное хранение артефактов и истории.
- **Cache/Queue** (Redis): антишторм-буферы, очереди эмбеддингов, токен-бункеты лимитов, быстрые флаги прогресса.
- **Observability** (OTel-стек): трейсы генераций/поиска, дашборды SLO, алерты.
- **Reverse Proxy**: TLS, компрессия, passthrough SSE, базовая защита.

## 4) Ключевые пользовательские потоки

### 4.1 Описание идеи → первичная память и черновик

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Web UI
    participant API as API Gateway
    participant BA as Business Analyst
    participant EMB as Embedding Service
    participant Q as Qdrant
    participant PS as Primary Store

    U->>UI: Вводит описание идеи
    UI->>API: POST /projects/{id}/step1
    API->>BA: Обработать идею

    loop Итеративное уточнение
        BA->>U: Вопросы для уточнения
        U->>BA: Ответы
    end

    BA->>PS: Сохранить черновик Description v1
    BA->>EMB: Извлечь ключевые факты
    EMB->>Q: Сохранить эмбеддинги (tenant_id, project_id)

    API-->>UI: SSE: Progress updates
    API->>UI: Description документ готов
```

- Пользователь излагает идею; Business Analyst уточняет и формирует структурный черновик Description.
- Черновик сразу сохраняется как версия документа; важные фрагменты и «факты» попадают в память проекта (эмбеддинги в Qdrant) в жёстком серверном скоупе `(tenant_id, project_id)`.
- SSE отдаёт прогресс (например, чек-пункты шаблона).

### 4.2 Спецификация

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Web UI
    participant API as API Gateway
    participant ES as Engineering Standards
    participant Q as Qdrant
    participant PS as Primary Store

    U->>UI: Запрос спецификации
    UI->>API: POST /projects/{id}/step2
    API->>ES: Создать спецификацию

    ES->>Q: Поиск контекста<br/>(tenant_id, project_id)
    Q->>ES: Релевантные факты из Description

    loop Выбор стандартов
        ES->>U: Предложения стандартов/процессов
        U->>ES: Выбор/корректировки
        Note over ES: Пересборка согласованной части
    end

    ES->>PS: Сохранить Engineering Specs v1
    API-->>UI: SSE: Progress updates
    API->>UI: Engineering Specs документ готов
```

- Engineering Standards извлекает контекст из памяти проекта (поиск только внутри текущего тенанта и проекта), предлагает технические требования и стандарты разработки, собирает документ Engineering Specs.
- Пользователь может быстро заменить подходы (например, TDD → BDD) — пересобирается согласованная часть документации.

### 4.3 Архитектура

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Web UI
    participant API as API Gateway
    participant SA as Solution Architect
    participant Q as Qdrant
    participant PS as Primary Store

    U->>UI: Запрос архитектуры
    UI->>API: POST /projects/{id}/step3
    API->>SA: Создать архитектуру

    SA->>Q: Поиск контекста<br/>(Description + Engineering Specs)
    Q->>SA: Полный контекст проекта

    SA->>PS: Анализ существующих артефактов
    PS->>SA: Description v1, Engineering Specs v1

    loop Выбор решений
        SA->>U: Предложения стека/паттернов
        U->>SA: Выбор/корректировки
        Note over SA: Пересборка согласованной части
    end

    SA->>PS: Сохранить Architecture v1
    API-->>UI: SSE: Progress updates
    API->>UI: Architecture документ готов
```

- Solution Architect извлекает контекст из памяти проекта (поиск только внутри текущего тенанта и проекта), предлагает решения (стек, паттерны, компромиссы), собирает документ Architecture на основе описания проекта и инженерных спецификаций.
- Пользователь может быстро заменить решения (например, Postgres → ClickHouse) — пересобирается согласованная часть документации.

### 4.4 Планирование

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Web UI
    participant API as API Gateway
    participant PP as Project Planner
    participant Q as Qdrant
    participant PS as Primary Store

    U->>UI: Запрос плана
    UI->>API: POST /projects/{id}/step4
    API->>PP: Создать план

    PP->>Q: Поиск полного контекста проекта
    Q->>PP: Description + Engineering Specs + Architecture

    PP->>PS: Анализ существующих артефактов
    PS->>PP: Description v1, Engineering Specs v1, Architecture v1

    loop Планирование этапов
        Note over PP: Формирование этапов
        Note over PP: Определение рисков
        Note over PP: Критерии приёмки
        PP->>U: Предварительный план
        U->>PP: Корректировки приоритетов
    end

    PP->>PS: Сохранить Implementation Plan v1
    PP->>UI: Настройка маячков напоминаний
    API-->>UI: SSE: Progress updates
    API->>UI: Implementation Plan готов
```

- Project Planner строит верхнеуровневый Implementation Plan: этапы, критерии приёмки, риски/зависимости, контрольные события на основе всех предыдущих документов.
- Настраиваются «маячки» для последующих напоминаний (например, «вернуться к интеграции партнёра Х»), которые отображаются в UI.

### 4.5 Финал — экспорт пакета

```mermaid
sequenceDiagram
    participant U as User
    participant UI as Web UI
    participant API as API Gateway
    participant EXP as Export Service
    participant PS as Primary Store

    U->>UI: Запрос экспорта пакета
    UI->>API: POST /projects/{id}/export
    API->>EXP: Подготовить архив

    EXP->>PS: Получить активные версии
    PS->>EXP: Description v1, Engineering Specs v1, Architecture v1, Implementation Plan v1

    loop Сборка пакета
        Note over EXP: Проверка целостности документов
        Note over EXP: Генерация манифеста
        Note over EXP: Структурирование папок
        Note over EXP: Markdown форматирование
    end

    EXP->>EXP: Создание ZIP архива
    EXP->>API: Архив готов
    API-->>UI: SSE: Progress updates
    API->>UI: Ссылка на скачивание

    U->>UI: Скачивание архива
    UI->>API: GET /exports/{export_id}
    API->>U: ZIP файл с документами
```

- API собирает «срез» активных версий артефактов на момент экспорта, формирует архив с чистой структурой папок Markdown.

## 5) Компоненты и их связи (подробно)

### 5.1 Frontend

- Одностраничный мастер с 4 шагами, каждый шаг — самостоятельный «чеклист» качества (заполняемость ключевых блоков).
- Дифф-подсветка между версиями документа; «быстрые кнопки» для принятия/отката.
- Прогресс-бар шага и общего процесса; состояние устойчиво к перезагрузке вкладки (стейт подтягивается из бэкенда).
- Изоляция проектов по URL: `app.tld/{tenant}/{project}` (path-based), с опцией вынести проекты крупных клиентов на поддомены при необходимости изоляции cookie/политик CORS.

### 5.2 API / Backend

- Аутентификация OAuth2; авторизация на основе ролей проекта (owner, editor, viewer).
- SSE-эндпоинты для прогресса генераций; backpressure-контроль, таймауты, реконнект.
- Rate-limiting: глобальные, per-tenant и per-project; отдельные квоты на токены LLM/эмбеддинги.
- Экспорт архива: сбор «активных» версий артефактов, генерация манифеста состава.

### 5.3 Оркестратор агентов

**Специализированные роли агентов:**

- **Business Analyst** — эксперт по product discovery и бизнес-анализу: исследует проблемную область, выявляет потребности пользователей, формулирует бизнес-цели и KPI, анализирует риски и ограничения
- **Engineering Standards** — senior engineer с экспертизой в code quality и best practices: формирует coding guidelines, определяет процессы code review, устанавливает Definition of Done и тестовые стандарты на основе описания проекта
- **Solution Architect** — технический архитектор с экспертизой в проектировании систем: выбирает технологический стек, проектирует компоненты и интеграции, обосновывает архитектурные решения и trade-offs с учетом установленных стандартов
- **Project Planner** — специалист по планированию разработки и управлению проектами: декомпозирует задачи, оценивает временные рамки, выявляет зависимости и bottlenecks, планирует milestone'ы на основе всех предыдущих артефактов

**Принципы работы:**

- Явные контракты I/O (строгая схема полей, чеклисты валидации), единый «контекст исполнения» с корреляционным ID.
- Итеративные циклы: уточнения → генерация → валидация → фиксация версии → (при необходимости) доработка.
- Жёсткое правило контекста: агенты читают память только в скоупе проекта; кросс-проектные запросы недоступны.

### 5.4 Сервис эмбеддингов

- Единая модель эмбеддингов на уровне MVP, чтобы сохранять однородность поиска и использовать мультитенантный подход в Qdrant эффективно (единая конфигурация векторов у всех тенантов).
- Политики чанкинга и фильтры (удаление стоп-сигналов, сжатие повторов), дедупликация перед записью в Vector Store.
- Контроль качества индекса: периодическая переиндексация «устаревших» фрагментов после значимых правок.

### 5.5 Vector Store (Qdrant) — Мультитенантный подход

- **Единая коллекция** с логическим разделением тенантов через payload-фильтрацию
- **Строгая изоляция:** все запросы выполняются только в контексте `(tenant_id, project_id)`
- **Оптимизированная конфигурация** для мультитенантных сред
- **Стратегии масштабирования:** от общего подхода до выделенных кластеров для крупных клиентов

> Подробные технические детали, включая конфигурацию HNSW и стратегии шардинга, описаны в [specs.md](specs.md). Дополнительно см. [The Tao of Qdrant Multi-tenancy](https://medium.com/qdrant/the-tao-of-qdrant-multi-tenancy-162c71f830fb).

### 5.6 Primary Store (артефакты и версии)

- Документы и их версии — «истина» для экспорта и отображения; память (Qdrant) — «индекс и контекст» для мышления агентов.
- Версионирование линейное в MVP с метаданными (кто/когда/почему), чтобы обеспечить объяснимость и быстрый откат.

### 5.7 Cache/Queue (Redis)

- Очередь вычисления эмбеддингов; антишторм-буферы при всплесках генераций; контрольные ключи прогресса для SSE.
- Токен-бюджеты на тенант/проект; смягчение «noisy neighbor» со стороны агентов (ограничение параллелизма).

### 5.8 Observability

- Сквозные трассы: шаг пользователя → вызовы агентов → эмбеддинги → Qdrant/Primary Store → экспорт; единый correlation-id.
- SLO дашборды: latency P50/P95 генераций, доля успешных экспортов, ошибки поиска, процент «пустых» релевантов.

### 5.9 Security & Privacy

- TLS везде; секреты только на сервере; принцип наименьших прав до уровня проекта.
- RBAC: владелец проекта, редактор, просмотровый доступ (включая публичный read-only флаг для публикаций).
- Политики хранения: ограничение сроков для логов с чувствительными фрагментами промптов/контекста; трейс-семплинг без персональных данных.

## 6) Мультитенантная модель памяти

**Подход:** единая коллекция Qdrant с логическим разделением через payload-фильтрацию.

**Принципы изоляции:**

- Все запросы строго в контексте `(tenant_id, project_id)`
- Серверная фильтрация — клиент не может обойти ограничения
- Оптимизированная конфигурация для производительности

> Детальные технические спецификации, включая конфигурацию HNSW, описаны в [specs.md](specs.md)

## 7) Масштабирование и производительность

- **Поиск**: мультитенантный подход + индекс по `tenant_id` обеспечивают устойчивую скорость на рост числа клиентов; оптимизация размещения векторов тенанта в Qdrant 1.11+ снижает I/O операции
- **Горизонтальный рост**: добавление узлов/шардов Qdrant; при необходимости — перенос отдельных клиентов на custom sharding/выделенный кластер (гибрид)
- **Оркестрация**: ограничение параллелизма на агента и на проект; очереди эмбеддингов; стратегия backoff при «узких местах»
- **Экспорт**: формирование архива из активных версий без блокирующего чтения всей истории

## 8) Развёртывание и окружения

### 8.1 Архитектура развёртывания

**Frontend:** Выполняется локально (Node.js/Vite) на порту 5200, не контейнеризован для удобства разработки

**Backend и инфраструктура:** Контейнеризованы через Docker Compose

**Порты:**

- Frontend (локально): 5200
- API: 5210
- PostgreSQL: 5220
- Qdrant: 5230
- Redis: 5240
- Nginx: 80, 443
- OpenTelemetry Collector: 4317, 4318, 8888
- HashiCorp Vault: 5250

### 8.2 Компоненты развёртывания

- **Среды:** dev / stage / prod; одинаковые артефакты контейнеров; единая модель эмбеддингов для всех в MVP (соответствует мультитенантному подходу)
- **Сетевые границы:** nginx с TLS, frontend через host.docker.internal:5200, приватные сети для Qdrant/Primary/Redis
- **Региональность:** по мере роста — региональные кластеры по требованию клиентов с учётом требований к размещению данных

### 8.3 Локальный стек

```yaml
services:
  # Инфраструктура (контейнеризована)
  - nginx: Reverse proxy и TLS терминация
  - api: FastAPI backend
  - postgres: PostgreSQL 18 with UUID v7 and AIO
  - redis: Cache и очереди
  - qdrant: Vector database
  - otel-collector: Телеметрия
  - vault: Управление секретами

  # Frontend (локально)
  - React/Vite на порту 5200
```

> **Управление секретами.** Рабочие токены Vault (`VAULT_TOKEN`,
> `VAULT_DEV_ROOT_TOKEN_ID`) задаём только через переменные окружения или
> локальный файл `.env.local`, который исключён из VCS. В корне репозитория
> хранится версионный шаблон `.env.example` с подсказками по структуре — его
> копируем при настройке окружения. Файлы `.env` с реальными значениями не
> коммитим и храним только локально.

## 9) Критерии качества и SLO

- **Время шага**: P95 генерации одного документа ≤ N секунд при базовом лимите объёма входа.
- **Доступность**: API и SSE ≥ 99.9% в месяц.
- **Безопасность**: 100% запросов к памяти проходят с серверным фильтром; 0 инцидентов кросс-тенантного доступа.

## 10) Риски и смягчение

- **«Шумные соседи»**: квоты на точки/запросы/токены; при превышении — деградация качества (меньше контекста, отложенные эмбеддинги), или перевод крупного клиента на custom sharding
- **Галлюцинации/рассинхрон артефактов**: жёсткие шаблоны и чек-листы валидации, строгие контракты I/O между агентами, явные правила «что считать источником истины»
- **Долгие ответы**: SSE, буферизация, показ промежуточных блоков, кэширование стабильных подсказок
- **Операционные издержки**: мультитенантный подход минимизирует их на старте; гибридная модель — по мере появления крупных клиентов
