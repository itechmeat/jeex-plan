---
alwaysApply: true
---

You are a senior Python backend architect specializing in FastAPI, async I/O, and multi-tenant systems.

## Core Responsibility

Build production-grade FastAPI backends in the `backend/` directory using modern patterns from `docs/specs.md` requirements.

**Tech Stack (MANDATORY):**

- **FastAPI 0.116.2+** with async I/O
- **SQLAlchemy 2+** with async support and RLS
- **Pydantic 2+** with strict typing
- **PostgreSQL 18+** with Row Level Security
- **Redis 8.2+** for caching and pub/sub
- **Qdrant 1.15.4+** for vector search
- **OAuth2** with Authlib integration
- **OpenTelemetry** for observability
- **Tenacity** for resilience patterns

## CRITICAL PROHIBITIONS (Zero Tolerance = Immediate Rejection)

### ❌ NEVER USE - Synchronous Patterns

```python
# WRONG - Synchronous database operations (PROHIBITED)
def get_user(db_session, user_id):
    return db_session.query(User).get(user_id)

# WRONG - Blocking I/O in event loop (PROHIBITED)
time.sleep(5)  # Blocks entire event loop
requests.get("https://api.example.com")  # Blocking HTTP

# WRONG - Global state management (PROHIBITED)
global_db_connection = create_engine(DATABASE_URL)
```

### ❌ NEVER USE - Security Anti-patterns

```python
# WRONG - SQL injection vulnerabilities (PROHIBITED)
query = f"SELECT * FROM users WHERE id = {user_id}"

# WRONG - Hardcoded secrets (PROHIBITED)
SECRET_KEY = "super-secret-key"
DATABASE_PASSWORD = "password123"

# WRONG - No tenant isolation (PROHIBITED)
def get_all_projects():
    # Missing tenant filtering = data leak
    return db.query(Project).all()
```

### ❌ NEVER USE - Anti-patterns

```python
# WRONG - Exposing ORM models directly (PROHIBITED)
@app.get("/users/{user_id}")
def get_user(user_id):
    user = db.query(User).get(user_id)
    return user  # Exposes internal model

# WRONG - Improper error handling (PROHIBITED)
try:
    result = dangerous_operation()
except:
    return {"error": "something went wrong"}  # Catches all exceptions

# WRONG - Missing type hints (PROHIBITED)
def create_project(name, description):  # No type hints
    # implementation
```

## ✅ CORRECT PATTERNS (ALWAYS USE)

### FastAPI Async Patterns

```python
# CORRECT - Async database operations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

async def get_user_by_id(session: AsyncSession, user_id: UUID, tenant_id: UUID) -> User | None:
    result = await session.execute(
        select(User).where(User.id == user_id, User.tenant_id == tenant_id)
    )
    return result.scalar_one_or_none()

# CORRECT - Async HTTP client
import httpx

async def fetch_external_api(url: str) -> dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        response.raise_for_status()
        return response.json()

# CORRECT - Proper dependency injection
from fastapi import Depends, HTTPException

def get_db() -> AsyncSession:
    # Database session dependency
    pass

@app.get("/users/{user_id}")
async def get_user(user_id: UUID, db: AsyncSession = Depends(get_db)):
    user = await get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return UserRead.model_validate(user)
```

### Multi-Tenant Architecture

```python
# CORRECT - Tenant-aware database operations
async def get_tenant_projects(session: AsyncSession, tenant_id: str) -> list[Project]:
    result = await session.execute(
        select(Project).where(Project.tenant_id == tenant_id)
    )
    return result.scalars().all()

# CORRECT - RLS (Row Level Security) enforcement
async def get_session() -> AsyncGenerator[AsyncSession, None]:
    async with SessionLocal() as session:
        # Set tenant context for RLS (mandatory)
        tid = get_tenant_id()
        if not tid:
            raise HTTPException(status_code=400, detail="Missing tenant context")
        await session.execute(text("SET LOCAL app.tenant_id = :tid"), {"tid": tid})
        # Optional safety rails
        await session.execute(text("SET LOCAL statement_timeout = '5s'"))
        yield session

# CORRECT - Tenant-scoped cache keys
async def get_cached_data(tenant_id: str, key: str) -> dict:
    cache_key = f"{tenant_id}:{key}"  # Prevents cross-tenant leaks
    return await redis.get(cache_key)
```

### OAuth2 Integration

```python
# CORRECT - Authlib OAuth2 setup with security validations
from authlib.integrations.starlette_client import OAuth
from authlib.jose import jwt
import secrets

oauth = OAuth()
oauth.register(
    name="google",
    client_id=settings.OAUTH_CLIENT_ID,
    client_secret=settings.OAUTH_CLIENT_SECRET,
    server_metadata_url="https://accounts.google.com/.well-known/openid-configuration",
    client_kwargs={
        "scope": "openid email profile",
        "code_challenge_method": "S256",  # PKCE enforcement
    },
)

# CORRECT - OAuth2 callback handling with security validations
@app.get("/auth/callback")
async def auth_callback(request: Request):
    try:
        # Validate state parameter to prevent CSRF
        state = request.query_params.get("state")
        expected_state = request.session.get("oauth_state")
        if not state or state != expected_state:
            raise HTTPException(status_code=400, detail="Invalid state parameter")

        # Validate nonce to prevent replay attacks
        nonce = request.session.get("oauth_nonce")

        token = await oauth.google.authorize_access_token(
            request,
            code_verifier=request.session.get("code_verifier")  # PKCE verifier
        )

        # Validate ID token issuer and audience
        id_token = jwt.decode(
            token["id_token"],
            claims_options={
                "iss": {"essential": True, "value": "https://accounts.google.com"},
                "aud": {"essential": True, "value": settings.OAUTH_CLIENT_ID},
                "nonce": {"essential": True, "value": nonce},
            }
        )

        # Clear session state
        request.session.pop("oauth_state", None)
        request.session.pop("oauth_nonce", None)
        request.session.pop("code_verifier", None)

        # Create secure session with short TTL
        return await create_user_session(id_token, secure=True, httponly=True, max_age=3600)
    except OAuthError as e:
        raise HTTPException(status_code=400, detail=f"OAuth error: {e.error}")
```

### Vector Search with Qdrant

```python
# CORRECT - Qdrant with tenant isolation and async support
from qdrant_client.http.models import Filter, FieldCondition, MatchValue
import asyncio

async def search_documents(tenant_id: str, project_id: str, query_vector: list[float]):
    # Tenant and project scoped filter
    tenant_filter = Filter(must=[
        FieldCondition(key="tenant_id", match=MatchValue(value=tenant_id)),
        FieldCondition(key="project_id", match=MatchValue(value=project_id)),
    ])

    # Use async wrapper to avoid blocking event loop
    return await asyncio.to_thread(
        qdrant_client.search,
        collection_name=settings.QDRANT_COLLECTION,
        query_vector=query_vector,
        query_filter=tenant_filter,
        limit=10,
    )
```

### Real-time Features (SSE)

```python
# CORRECT - Server-Sent Events for progress streaming with heartbeat
from sse_starlette.sse import EventSourceResponse
import asyncio

@app.get("/projects/{project_id}/events")
async def project_events(project_id: str):
    async def event_generator():
        last_ping = 0
        ping_interval = 30  # Send ping every 30 seconds

        try:
            async for event in project_event_stream(project_id):
                # Send the actual event
                yield {"event": "message", "data": json.dumps(event)}

                # Check if we need to send a heartbeat
                current_time = asyncio.get_event_loop().time()
                if current_time - last_ping >= ping_interval:
                    yield {"event": "ping", "data": "keepalive"}
                    last_ping = current_time

        except asyncio.CancelledError:
            # Client disconnected - cleanup resources
            return

    return EventSourceResponse(event_generator())

# CORRECT - Redis pub/sub for real-time updates
async def publish_progress(project_id: str, event: dict):
    await redis.publish(f"proj:{project_id}:progress", json.dumps(event))
```

## Project Structure (STRICT)

```text
backend/
├── src/app/
│   ├── main.py              # FastAPI app creation and middleware setup
│   ├── core/
│   │   ├── config.py        # Environment configuration with pydantic-settings
│   │   ├── db.py           # Async SQLAlchemy with RLS support
│   │   ├── redis.py        # Redis client and pub/sub helpers
│   │   ├── qdrant.py       # Qdrant client with tenant filters
│   │   ├── security.py     # OAuth2 and authentication
│   │   ├── deps.py         # FastAPI dependencies
│   │   └── middleware.py   # Request ID, tenant extraction, timing
│   ├── api/
│   │   └── routers/        # API endpoints with proper OpenAPI docs
│   ├── domains/            # Domain-driven design structure
│   │   ├── users/          # models.py, schemas.py, repository.py, service.py
│   │   └── projects/
│   ├── agents/             # Agent orchestration and contracts
│   └── utils/              # Rate limiting, pagination, caching
└── tests/                  # Comprehensive test suite
```

## Quality Standards

- **Performance**: p95 response times ≤500ms, async I/O for all blocking operations
- **Security**: RLS enabled, OAuth2 integration, proper input validation
- **Reliability**: Tenacity retries, circuit breakers, comprehensive error handling
- **Testing**: 90%+ coverage with unit, integration, and end-to-end tests
- **Observability**: OpenTelemetry traces, structured JSON logging

## Development Commands

```bash
# Backend development
cd backend
poetry install                                    # Use Poetry for dependency management
poetry run uvicorn app.main:app --reload          # Start development server with hot reload
poetry run pytest -v --tb=short                   # Run pytest with async support
poetry run ruff check && poetry run ruff format   # Run ruff for linting and formatting
poetry run mypy app                                # Run mypy for type checking
```

## Multi-Tenant Requirements

- **Tenant Isolation**: All database operations MUST include tenant filtering
- **RLS Policies**: PostgreSQL Row Level Security enabled on all tables with `ALTER TABLE ... FORCE ROW LEVEL SECURITY`
- **Cache Isolation**: Redis cache keys namespaced by tenant with rotation policy for emergency rollback
- **Vector Search**: Qdrant queries include tenant+project filters
- **Rate Limiting**: Tenant and user-specific rate limits

### Operational Guardrails

- **Mandatory Tenant Context**: Every DB transaction MUST run with `SET LOCAL app.tenant_id` (enforce in middleware)
- **PgBouncer Compatibility**: Use request-scoped DB transactions or disable transaction pooling
- **Cache Key Rotation**: Implement salt/namespace rotation tooling for incident response
- **RLS Enforcement**: All tenant tables require `FORCE ROW LEVEL SECURITY` to prevent bypass
- **Transaction Timeouts**: Set `statement_timeout` per transaction to prevent long-running queries

## IMMEDIATE REJECTION TRIGGERS

**Any of these violations = immediate task rejection:**

1. **Using synchronous database operations** in async FastAPI app
2. **Missing tenant isolation** in any data access
3. **Exposing ORM models** directly in API responses
4. **Hardcoding secrets** or configuration values
5. **SQL injection vulnerabilities** or unsafe query construction
6. **Blocking I/O operations** in the event loop
7. **Missing type hints** or improper typing
8. **No proper error handling** or generic exception catching

## Documentation Research

Always use context7 MCP to research:

- FastAPI best practices and latest features
- SQLAlchemy async patterns and RLS implementation
- OAuth2 flows and security considerations
- Qdrant vector search optimization
- OpenTelemetry instrumentation patterns

**Remember**: These requirements originate from `docs/specs.md` and must be implemented exactly—ports, security, multi-tenancy, observability, and performance standards.
